{
    "ExternalFilesEntryLinker": {
        "imports_documentation": {
            "org.jabref.gui.externalfiles": null,
            "org.jabref.gui.externalfiletype.ExternalFileType": null,
            "org.jabref.gui.externalfiletype.ExternalFileTypes": null,
            "org.jabref.gui.externalfiletype.UnknownExternalFileType": null,
            "org.jabref.logic.cleanup.MoveFilesCleanup": null,
            "org.jabref.logic.cleanup.RenamePdfCleanup": null,
            "org.jabref.logic.pdf.search.indexing.IndexingTaskManager": null,
            "org.jabref.logic.pdf.search.indexing.PdfIndexer": null,
            "org.jabref.logic.util.io.FileUtil": null,
            "org.jabref.model.database.BibDatabaseContext": null,
            "org.jabref.model.entry.BibEntry": null,
            "org.jabref.model.entry.LinkedFile": null,
            "org.jabref.preferences.FilePreferences": null,
            "org.slf4j.Logger": "Logger (SLF4J javadoc) JavaScript is disabled on your browser. Skip navigation links Overview Package Class Use Tree Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field | Constr\u00a0| Method Detail: Field | Constr\u00a0| Method SEARCH Package org.slf4j Interface Logger All Known Subinterfaces: LocationAwareLogger All Known Implementing Classes: AbstractLogger , EventRecordingLogger , JDK14LoggerAdapter , LegacyAbstractLogger , LocLogger , LoggerWrapper , MarkerIgnoringBase , NOPLogger , Reload4jLoggerAdapter , SimpleLogger , SubstituteLogger , XLogger public interface Logger The org.slf4j.Logger interface is the main user entry point of SLF4J API.\n It is expected that logging takes place through concrete implementations\n of this interface. Typical usage pattern: import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n\n public class Wombat { final static Logger logger = LoggerFactory.getLogger(Wombat.class); Integer t;\n   Integer oldT;\n\n   public void setTemperature(Integer temperature) {\n     oldT = t;\n     t = temperature; logger.debug(\"Temperature set to {}. Old temperature was {}.\", t, oldT); if (temperature.intValue() > 50) { logger.info(\"Temperature has risen above 50 degrees.\"); }\n   }\n } Note that version 2.0 of the SLF4J API introduces a fluent api ,\n the most significant API change to occur in the last 20 years. Be sure to read the FAQ entry relating to parameterized\n logging . Note that logging statements can be parameterized in presence of an exception/throwable . Once you are comfortable using loggers, i.e. instances of this interface, consider using MDC as well as Markers . Author: Ceki G\u00fclc\u00fc Field Summary Fields Modifier and Type Field Description static final String ROOT_LOGGER_NAME Case-insensitive String constant used to retrieve the name of the root logger. Method Summary All Methods Instance Methods Abstract Methods Default Methods Modifier and Type Method Description default LoggingEventBuilder atDebug () Entry point for fluent-logging for Level.DEBUG level. default LoggingEventBuilder atError () Entry point for fluent-logging for Level.ERROR level. default LoggingEventBuilder atInfo () Entry point for fluent-logging for Level.INFO level. default LoggingEventBuilder atLevel ( Level level) Make a new LoggingEventBuilder instance as appropriate for this logger and the\n desired Level passed as parameter. default LoggingEventBuilder atTrace () Entry point for fluent-logging for Level.TRACE level. default LoggingEventBuilder atWarn () Entry point for fluent-logging for Level.WARN level. void debug ( String msg) Log a message at the DEBUG level. void debug ( String format, Object arg) Log a message at the DEBUG level according to the specified format\n and argument. void debug ( String format, Object ...\u00a0arguments) Log a message at the DEBUG level according to the specified format\n and arguments. void debug ( String format, Object arg1, Object arg2) Log a message at the DEBUG level according to the specified format\n and arguments. void debug ( String msg, Throwable t) Log an exception (throwable) at the DEBUG level with an\n accompanying message. void debug ( Marker marker, String msg) Log a message with the specific Marker at the DEBUG level. void debug ( Marker marker, String format, Object arg) This method is similar to debug(String, Object) method except that the\n marker data is also taken into consideration. void debug ( Marker marker, String format, Object ...\u00a0arguments) This method is similar to debug(String, Object...) method except that the marker data is also taken into\n consideration. void debug ( Marker marker, String format, Object arg1, Object arg2) This method is similar to debug(String, Object, Object) method except that the marker data is also taken into\n consideration. void debug ( Marker marker, String msg, Throwable t) This method is similar to debug(String, Throwable) method except that the\n marker data is also taken into consideration. void error ( String msg) Log a message at the ERROR level. void error ( String format, Object arg) Log a message at the ERROR level according to the specified format\n and argument. void error ( String format, Object ...\u00a0arguments) Log a message at the ERROR level according to the specified format\n and arguments. void error ( String format, Object arg1, Object arg2) Log a message at the ERROR level according to the specified format\n and arguments. void error ( String msg, Throwable t) Log an exception (throwable) at the ERROR level with an\n accompanying message. void error ( Marker marker, String msg) Log a message with the specific Marker at the ERROR level. void error ( Marker marker, String format, Object arg) This method is similar to error(String, Object) method except that the\n marker data is also taken into consideration. void error ( Marker marker, String format, Object ...\u00a0arguments) This method is similar to error(String, Object...) method except that the marker data is also taken into\n consideration. void error ( Marker marker, String format, Object arg1, Object arg2) This method is similar to error(String, Object, Object) method except that the marker data is also taken into\n consideration. void error ( Marker marker, String msg, Throwable t) This method is similar to error(String, Throwable) method except that the marker data is also taken into\n consideration. String getName () Return the name of this Logger instance. void info ( String msg) Log a message at the INFO level. void info ( String format, Object arg) Log a message at the INFO level according to the specified format\n and argument. void info ( String format, Object ...\u00a0arguments) Log a message at the INFO level according to the specified format\n and arguments. void info ( String format, Object arg1, Object arg2) Log a message at the INFO level according to the specified format\n and arguments. void info ( String msg, Throwable t) Log an exception (throwable) at the INFO level with an\n accompanying message. void info ( Marker marker, String msg) Log a message with the specific Marker at the INFO level. void info ( Marker marker, String format, Object arg) This method is similar to info(String, Object) method except that the\n marker data is also taken into consideration. void info ( Marker marker, String format, Object ...\u00a0arguments) This method is similar to info(String, Object...) method except that the marker data is also taken into\n consideration. void info ( Marker marker, String format, Object arg1, Object arg2) This method is similar to info(String, Object, Object) method except that the marker data is also taken into\n consideration. void info ( Marker marker, String msg, Throwable t) This method is similar to info(String, Throwable) method\n except that the marker data is also taken into consideration. boolean isDebugEnabled () Is the logger instance enabled for the DEBUG level? boolean isDebugEnabled ( Marker marker) Similar to isDebugEnabled() method except that the\n marker data is also taken into account. default boolean isEnabledForLevel ( Level level) Returns whether this Logger is enabled for a given Level . boolean isErrorEnabled () Is the logger instance enabled for the ERROR level? boolean isErrorEnabled ( Marker marker) Similar to isErrorEnabled() method except that the\n marker data is also taken into consideration. boolean isInfoEnabled () Is the logger instance enabled for the INFO level? boolean isInfoEnabled ( Marker marker) Similar to isInfoEnabled() method except that the marker\n data is also taken into consideration. boolean isTraceEnabled () Is the logger instance enabled for the TRACE level? boolean isTraceEnabled ( Marker marker) Similar to isTraceEnabled() method except that the\n marker data is also taken into account. boolean isWarnEnabled () Is the logger instance enabled for the WARN level? boolean isWarnEnabled ( Marker marker) Similar to isWarnEnabled() method except that the marker\n data is also taken into consideration. default LoggingEventBuilder makeLoggingEventBuilder ( Level level) Make a new LoggingEventBuilder instance as appropriate for this logger implementation. void trace ( String msg) Log a message at the TRACE level. void trace ( String format, Object arg) Log a message at the TRACE level according to the specified format\n and argument. void trace ( String format, Object ...\u00a0arguments) Log a message at the TRACE level according to the specified format\n and arguments. void trace ( String format, Object arg1, Object arg2) Log a message at the TRACE level according to the specified format\n and arguments. void trace ( String msg, Throwable t) Log an exception (throwable) at the TRACE level with an\n accompanying message. void trace ( Marker marker, String msg) Log a message with the specific Marker at the TRACE level. void trace ( Marker marker, String format, Object arg) This method is similar to trace(String, Object) method except that the\n marker data is also taken into consideration. void trace ( Marker marker, String format, Object ...\u00a0argArray) This method is similar to trace(String, Object...) method except that the marker data is also taken into\n consideration. void trace ( Marker marker, String format, Object arg1, Object arg2) This method is similar to trace(String, Object, Object) method except that the marker data is also taken into\n consideration. void trace ( Marker marker, String msg, Throwable t) This method is similar to trace(String, Throwable) method except that the\n marker data is also taken into consideration. void warn ( String msg) Log a message at the WARN level. void warn ( String format, Object arg) Log a message at the WARN level according to the specified format\n and argument. void warn ( String format, Object ...\u00a0arguments) Log a message at the WARN level according to the specified format\n and arguments. void warn ( String format, Object arg1, Object arg2) Log a message at the WARN level according to the specified format\n and arguments. void warn ( String msg, Throwable t) Log an exception (throwable) at the WARN level with an\n accompanying message. void warn ( Marker marker, String msg) Log a message with the specific Marker at the WARN level. void warn ( Marker marker, String format, Object arg) This method is similar to warn(String, Object) method except that the\n marker data is also taken into consideration. void warn ( Marker marker, String format, Object ...\u00a0arguments) This method is similar to warn(String, Object...) method except that the marker data is also taken into\n consideration. void warn ( Marker marker, String format, Object arg1, Object arg2) This method is similar to warn(String, Object, Object) method except that the marker data is also taken into\n consideration. void warn ( Marker marker, String msg, Throwable t) This method is similar to warn(String, Throwable) method\n except that the marker data is also taken into consideration. Field Details ROOT_LOGGER_NAME static final String ROOT_LOGGER_NAME Case-insensitive String constant used to retrieve the name of the root logger. Since:",
            "org.slf4j.LoggerFactory": "LoggerFactory (SLF4J javadoc) JavaScript is disabled on your browser. Skip navigation links Overview Package Class Use Tree Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field | Constr\u00a0| Method Detail: Field | Constr\u00a0| Method SEARCH Package org.slf4j Class LoggerFactory java.lang.Object org.slf4j.LoggerFactory public final class LoggerFactory extends Object The LoggerFactory is a utility class producing Loggers for\n various logging APIs, e.g. logback, reload4j, log4j and JDK 1.4 logging.\n Other implementations such as NOPLogger and\n SimpleLogger are also supported. LoggerFactory is essentially a wrapper around an ILoggerFactory instance provided by a SLF4JServiceProvider . Please note that all methods in LoggerFactory are static. Author: Alexander Dorokhine, Robert Elliot, Ceki G\u00fclc\u00fc Field Summary Fields Modifier and Type Field Description static final String PROVIDER_PROPERTY_KEY System property for explicitly setting the provider class. Method Summary All Methods Static Methods Concrete Methods Modifier and Type Method Description static ILoggerFactory getILoggerFactory () Return the ILoggerFactory instance in use. static Logger getLogger ( Class <?>\u00a0clazz) Return a logger named corresponding to the class passed as parameter,\n using the statically bound ILoggerFactory instance. static Logger getLogger ( String name) Return a logger named according to the name parameter using the\n statically bound ILoggerFactory instance. Methods inherited from class\u00a0java.lang. Object clone , equals , finalize , getClass , hashCode , notify , notifyAll , toString , wait , wait , wait Field Details PROVIDER_PROPERTY_KEY public static final String PROVIDER_PROPERTY_KEY System property for explicitly setting the provider class. If set and the provider could be instantiated,\n then the service loading mechanism will be bypassed. Since:",
            "java.io.IOException": "IOException (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.io Class IOException java.lang.Object java.lang.Throwable java.lang.Exception java.io.IOException All Implemented Interfaces: Serializable Direct Known Subclasses: AttachOperationFailedException , ChangedCharSetException , CharacterCodingException , CharConversionException , ClosedChannelException , ClosedConnectionException , EOFException , FileLockInterruptionException , FileNotFoundException , FilerException , FileSystemException , HttpRetryException , HttpTimeoutException , IIOException , InterruptedByTimeoutException , InterruptedIOException , InvalidPropertiesFormatException , JMXProviderException , JMXServerErrorException , MalformedURLException , ObjectStreamException , ProtocolException , RemoteException , SaslException , SocketException , SSLException , SyncFailedException , TransportTimeoutException , UnknownHostException , UnknownServiceException , UnsupportedEncodingException , UserPrincipalNotFoundException , UTFDataFormatException , WebSocketHandshakeException , ZipException public class IOException extends Exception Signals that an I/O exception of some sort has occurred. This\n class is the general class of exceptions produced by failed or\n interrupted I/O operations. Since:",
            "java.nio.file.Path": "Path (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.nio.file Interface Path All Superinterfaces: Comparable < Path > , Iterable < Path > , Watchable public interface Path extends Comparable < Path >, Iterable < Path >, Watchable An object that may be used to locate a file in a file system. It will\n typically represent a system dependent file path. A Path represents a path that is hierarchical and composed of a\n sequence of directory and file name elements separated by a special separator\n or delimiter. A root component , that identifies a file system\n hierarchy, may also be present. The name element that is farthest from the root of the directory hierarchy is the name of a file or directory.\n The other name elements are directory names. A Path can represent a\n root, a root and a sequence of names, or simply one or more name elements.\n A Path is considered to be an empty path if it consists\n solely of one name element that is empty. Accessing a file using an empty path is equivalent to accessing the default directory of the\n file system. Path defines the getFileName , getParent , getRoot , and subpath methods to access the path components or a subsequence of its name\n elements. In addition to accessing the components of a path, a Path also\n defines the resolve and resolveSibling methods to combine paths. The relativize method that can be used to construct a relative path between two paths.\n Paths can be compared , and tested against each other using\n the startsWith and endsWith methods. This interface extends Watchable interface so that a directory\n located by a path can be registered with a WatchService and entries in the directory watched. WARNING: This interface is only intended to be implemented by\n those developing custom file system implementations. Methods may be added to\n this interface in future releases. Accessing Files Paths may be used with the Files class to operate on files,\n directories, and other types of files. For example, suppose we want a BufferedReader to read text from a file \" access.log \". The\n file is located in a directory \" logs \" relative to the current working\n directory and is UTF-8 encoded. Copy Path path = FileSystems.getDefault().getPath(\"logs\", \"access.log\");\n    BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8); Interoperability Paths associated with the default provider are generally interoperable\n with the java.io.File class. Paths created by other\n providers are unlikely to be interoperable with the abstract path names\n represented by java.io.File . The toPath method may be used to obtain a Path from the abstract path name\n represented by a java.io.File object. The resulting Path can\n be used to operate on the same file as the java.io.File object. In\n addition, the toFile method is useful to construct a File from the String representation of a Path . Concurrency Implementations of this interface are immutable and safe for use by\n multiple concurrent threads. Since:",
            "java.util.List": "List (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util Interface List<E> Type Parameters: E - the type of elements in this list All Superinterfaces: Collection <E> , Iterable <E> , SequencedCollection <E> All Known Implementing Classes: AbstractList , AbstractSequentialList , ArrayList , AttributeList , CopyOnWriteArrayList , LinkedList , RoleList , RoleUnresolvedList , Stack , Vector public interface List<E> extends SequencedCollection <E> An ordered collection, where the user has precise control over where in the\n list each element is inserted.  The user can access elements by their integer\n index (position in the list), and search for elements in the list. Unlike sets, lists typically allow duplicate elements.  More formally,\n lists typically allow pairs of elements e1 and e2 such that e1.equals(e2) , and they typically allow multiple\n null elements if they allow null elements at all.  It is not inconceivable\n that someone might wish to implement a list that prohibits duplicates, by\n throwing runtime exceptions when the user attempts to insert them, but we\n expect this usage to be rare. The List interface places additional stipulations, beyond those\n specified in the Collection interface, on the contracts of the iterator , add , remove , equals , and hashCode methods.  Declarations for other inherited methods are\n also included here for convenience. The List interface provides four methods for positional (indexed)\n access to list elements.  Lists (like Java arrays) are zero based.  Note\n that these operations may execute in time proportional to the index value\n for some implementations (the LinkedList class, for\n example). Thus, iterating over the elements in a list is typically\n preferable to indexing through it if the caller does not know the\n implementation. The List interface provides a special iterator, called a ListIterator , that allows element insertion and replacement, and\n bidirectional access in addition to the normal operations that the Iterator interface provides.  A method is provided to obtain a\n list iterator that starts at a specified position in the list. The List interface provides two methods to search for a specified\n object.  From a performance standpoint, these methods should be used with\n caution.  In many implementations they will perform costly linear\n searches. The List interface provides two methods to efficiently insert and\n remove multiple elements at an arbitrary point in the list. Note: While it is permissible for lists to contain themselves as elements,\n extreme caution is advised: the equals and hashCode methods are no longer well defined on such a list. Some list implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException .  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the list may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface. Unmodifiable Lists The List.of and List.copyOf static factory methods\n provide a convenient way to create unmodifiable lists. The List instances created by these methods have the following characteristics: They are unmodifiable . Elements cannot\n be added, removed, or replaced. Calling any mutator method on the List\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained elements are themselves mutable,\n this may cause the List's contents to appear to change. They disallow null elements. Attempts to create them with null elements result in NullPointerException . They are serializable if all elements are serializable. The order of elements in the list is the same as the order of the\n provided arguments, or of the elements in the provided array. The lists and their subList views implement the RandomAccess interface. They are value-based .\n Programmers should treat instances that are equal as interchangeable and should not use them for synchronization, or\n unpredictable behavior may occur. For example, in a future release,\n synchronization may fail. Callers should make no assumptions about the\n identity of the returned instances. Factories are free to\n create new instances or reuse existing ones. They are serialized as specified on the Serialized Form page. This interface is a member of the Java Collections Framework . Since:",
            "java.util.Optional": "Optional (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util Class Optional<T> java.lang.Object java.util.Optional<T> Type Parameters: T - the type of value public final class Optional<T> extends Object A container object which may or may not contain a non- null value.\n If a value is present, isPresent() returns true . If no\n value is present, the object is considered empty and isPresent() returns false . Additional methods that depend on the presence or absence of a contained\n value are provided, such as orElse() (returns a default value if no value is present) and ifPresent() (performs an\n action if a value is present). This is a value-based class; programmers should treat instances that are equal as interchangeable and should not\n use instances for synchronization, or unpredictable behavior may\n occur. For example, in a future release, synchronization may fail. API Note: Optional is primarily intended for use as a method return type where\n there is a clear need to represent \"no result,\" and where using null is likely to cause errors. A variable whose type is Optional should\n never itself be null ; it should always point to an Optional instance. Since:"
        },
        "classes_labeled": {
            "externalfiles": "Utility",
            "ExternalFileType": "Utility",
            "ExternalFileTypes": "Utility",
            "UnknownExternalFileType": "Utility",
            "MoveFilesCleanup": "Utility",
            "RenamePdfCleanup": "Utility",
            "IndexingTaskManager": "Software Development and IT Operation",
            "PdfIndexer": "Parser",
            "FileUtil": "Utility",
            "BibDatabaseContext": "Databases",
            "BibEntry": "Parser",
            "LinkedFile": "Utility",
            "FilePreferences": "Utility",
            "Logger": "Logging",
            "LoggerFactory": "Logging",
            "IOException": "Error Handling",
            "Path": "Parser",
            "List": "Data Structure",
            "Optional": "Data Structure"
        },
        "function_summaries": {
            "getLogger": "Logging",
            "getFirstExistingFileDir": "Retrieval",
            "isPresent": "Validation",
            "get": "Creation",
            "getFileName": "Operation",
            "copyFile": "Operation",
            "ofNullable": "Validation",
            "empty": "Operation",
            "cleanup": "Cleanup",
            "getFileExtension": "Parsing",
            "getExternalFileTypeByExt": "Retrieval",
            "relativize": "Transformation",
            "getFileDirectories": "Mapping",
            "getName": "Operation",
            "addFile": "Modification",
            "blockNewTasks": "Synchronization",
            "error": "Error Handling",
            "addToIndex": "Integration",
            "of": "Creation"
        },
        "functions_labeled": {
            "getLogger": "Logging",
            "getFirstExistingFileDir": "Retrieval",
            "isPresent": "Validation",
            "get": "Creation",
            "getFileName": "Operation",
            "copyFile": "Operation",
            "ofNullable": "Validation",
            "empty": "Operation",
            "cleanup": "Cleanup",
            "getFileExtension": "Parsing",
            "getExternalFileTypeByExt": "Retrieval",
            "relativize": "Transformation",
            "getFileDirectories": "Mapping",
            "getName": "Operation",
            "addFile": "Modification",
            "blockNewTasks": "Synchronization",
            "error": "Error Handling",
            "addToIndex": "Integration",
            "of": "Creation"
        }
    },
    "AutosaveManager": {
        "imports_documentation": {
            "org.jabref.logic.autosaveandbackup": null,
            "java.util.HashSet": "HashSet (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.util Class HashSet<E> java.lang.Object java.util.AbstractCollection <E> java.util.AbstractSet <E> java.util.HashSet<E> Type Parameters: E - the type of elements maintained by this set All Implemented Interfaces: Serializable , Cloneable , Iterable <E> , Collection <E> , Set <E> Direct Known Subclasses: JobStateReasons , LinkedHashSet public class HashSet<E> extends AbstractSet <E>\nimplements Set <E>, Cloneable , Serializable This class implements the Set interface, backed by a hash table\n (actually a HashMap instance).  It makes no guarantees as to the\n iteration order of the set; in particular, it does not guarantee that the\n order will remain constant over time.  This class permits the null element. This class offers constant time performance for the basic operations\n ( add , remove , contains and size ),\n assuming the hash function disperses the elements properly among the\n buckets.  Iterating over this set requires time proportional to the sum of\n the HashSet instance's size (the number of elements) plus the\n \"capacity\" of the backing HashMap instance (the number of\n buckets).  Thus, it's very important not to set the initial capacity too\n high (or the load factor too low) if iteration performance is important. Note that this implementation is not synchronized. If multiple threads access a hash set concurrently, and at least one of\n the threads modifies the set, it must be synchronized externally.\n This is typically accomplished by synchronizing on some object that\n naturally encapsulates the set.\n\n If no such object exists, the set should be \"wrapped\" using the Collections.synchronizedSet method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the set: Set s = Collections.synchronizedSet(new HashSet(...)); The iterators returned by this class's iterator method are fail-fast : if the set is modified at any time after the iterator is\n created, in any way except through the iterator's own remove method, the Iterator throws a ConcurrentModificationException .\n Thus, in the face of concurrent modification, the iterator fails quickly\n and cleanly, rather than risking arbitrary, non-deterministic behavior at\n an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness: the fail-fast behavior of iterators\n should be used only to detect bugs. This class is a member of the Java Collections Framework . Since:",
            "java.util.Set": "Set (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util Interface Set<E> Type Parameters: E - the type of elements maintained by this set All Superinterfaces: Collection <E> , Iterable <E> All Known Subinterfaces: EventSet , NavigableSet <E> , SequencedSet <E> , SortedSet <E> All Known Implementing Classes: AbstractSet , ConcurrentHashMap.KeySetView , ConcurrentSkipListSet , CopyOnWriteArraySet , EnumSet , HashSet , JobStateReasons , LinkedHashSet , TreeSet public interface Set<E> extends Collection <E> A collection that contains no duplicate elements.  More formally, sets\n contain no pair of elements e1 and e2 such that e1.equals(e2) , and at most one null element.  As implied by\n its name, this interface models the mathematical set abstraction. The Set interface places additional stipulations, beyond those\n inherited from the Collection interface, on the contracts of all\n constructors and on the contracts of the add , equals and hashCode methods.  Declarations for other inherited methods are\n also included here for convenience.  (The specifications accompanying these\n declarations have been tailored to the Set interface, but they do\n not contain any additional stipulations.) The additional stipulation on constructors is, not surprisingly,\n that all constructors must create a set that contains no duplicate elements\n (as defined above). Note: Great care must be exercised if mutable objects are used as set\n elements.  The behavior of a set is not specified if the value of an object\n is changed in a manner that affects equals comparisons while the\n object is an element in the set.  A special case of this prohibition is\n that it is not permissible for a set to contain itself as an element. Some set implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException .  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the set may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface. Unmodifiable Sets The Set.of and Set.copyOf static factory methods\n provide a convenient way to create unmodifiable sets. The Set instances created by these methods have the following characteristics: They are unmodifiable . Elements cannot\n be added or removed. Calling any mutator method on the Set\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained elements are themselves mutable, this may cause the\n Set to behave inconsistently or its contents to appear to change. They disallow null elements. Attempts to create them with null elements result in NullPointerException . They are serializable if all elements are serializable. They reject duplicate elements at creation time. Duplicate elements\n passed to a static factory method result in IllegalArgumentException . The iteration order of set elements is unspecified and is subject to change. They are value-based .\n Programmers should treat instances that are equal as interchangeable and should not use them for synchronization, or\n unpredictable behavior may occur. For example, in a future release,\n synchronization may fail. Callers should make no assumptions\n about the identity of the returned instances. Factories are free to\n create new instances or reuse existing ones. They are serialized as specified on the Serialized Form page. This interface is a member of the Java Collections Framework . Since:",
            "java.util.concurrent.ArrayBlockingQueue": "ArrayBlockingQueue (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.util.concurrent Class ArrayBlockingQueue<E> java.lang.Object java.util.AbstractCollection <E> java.util.AbstractQueue <E> java.util.concurrent.ArrayBlockingQueue<E> Type Parameters: E - the type of elements held in this queue All Implemented Interfaces: Serializable , Iterable <E> , Collection <E> , BlockingQueue <E> , Queue <E> public class ArrayBlockingQueue<E> extends AbstractQueue <E>\nimplements BlockingQueue <E>, Serializable A bounded blocking queue backed by an\n array.  This queue orders elements FIFO (first-in-first-out).  The head of the queue is that element that has been on the\n queue the longest time.  The tail of the queue is that\n element that has been on the queue the shortest time. New elements\n are inserted at the tail of the queue, and the queue retrieval\n operations obtain elements at the head of the queue. This is a classic \"bounded buffer\", in which a\n fixed-sized array holds elements inserted by producers and\n extracted by consumers.  Once created, the capacity cannot be\n changed.  Attempts to put an element into a full queue\n will result in the operation blocking; attempts to take an\n element from an empty queue will similarly block. This class supports an optional fairness policy for ordering\n waiting producer and consumer threads.  By default, this ordering\n is not guaranteed. However, a queue constructed with fairness set\n to true grants threads access in FIFO order. Fairness\n generally decreases throughput but reduces variability and avoids\n starvation. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the Java Collections Framework . Since:",
            "java.util.concurrent.BlockingQueue": "BlockingQueue (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util.concurrent Interface BlockingQueue<E> Type Parameters: E - the type of elements held in this queue All Superinterfaces: Collection <E> , Iterable <E> , Queue <E> All Known Subinterfaces: BlockingDeque <E> , TransferQueue <E> All Known Implementing Classes: ArrayBlockingQueue , DelayQueue , LinkedBlockingDeque , LinkedBlockingQueue , LinkedTransferQueue , PriorityBlockingQueue , SynchronousQueue public interface BlockingQueue<E> extends Queue <E> A Queue that additionally supports operations that wait for\n the queue to become non-empty when retrieving an element, and wait\n for space to become available in the queue when storing an element. BlockingQueue methods come in four forms, with different ways\n of handling operations that cannot be satisfied immediately, but may be\n satisfied at some point in the future:\n one throws an exception, the second returns a special value (either null or false , depending on the operation), the third\n blocks the current thread indefinitely until the operation can succeed,\n and the fourth blocks for only a given maximum time limit before giving\n up.  These methods are summarized in the following table: Summary of BlockingQueue methods Throws exception Special value Blocks Times out Insert add(e) offer(e) put(e) offer(e, time, unit) Remove remove() poll() take() poll(time, unit) Examine element() peek() not applicable not applicable A BlockingQueue does not accept null elements.\n Implementations throw NullPointerException on attempts\n to add , put or offer a null .  A null is used as a sentinel value to indicate failure of poll operations. A BlockingQueue may be capacity bounded. At any given\n time it may have a remainingCapacity beyond which no\n additional elements can be put without blocking.\n A BlockingQueue without any intrinsic capacity constraints always\n reports a remaining capacity of Integer.MAX_VALUE . BlockingQueue implementations are designed to be used\n primarily for producer-consumer queues, but additionally support\n the Collection interface.  So, for example, it is\n possible to remove an arbitrary element from a queue using remove(x) . However, such operations are in general not performed very efficiently, and are intended for only\n occasional use, such as when a queued message is cancelled. BlockingQueue implementations are thread-safe.  All\n queuing methods achieve their effects atomically using internal\n locks or other forms of concurrency control. However, the bulk Collection operations addAll , containsAll , retainAll and removeAll are not necessarily performed atomically unless specified\n otherwise in an implementation. So it is possible, for example, for addAll(c) to fail (throwing an exception) after adding\n only some of the elements in c . A BlockingQueue does not intrinsically support\n any kind of \"close\" or \"shutdown\" operation to\n indicate that no more items will be added.  The needs and usage of\n such features tend to be implementation-dependent. For example, a\n common tactic is for producers to insert special end-of-stream or poison objects, that are\n interpreted accordingly when taken by consumers. Usage example, based on a typical producer-consumer scenario.\n Note that a BlockingQueue can safely be used with multiple\n producers and multiple consumers. class Producer implements Runnable {\n   private final BlockingQueue queue;\n   Producer(BlockingQueue q) { queue = q; }\n   public void run() {\n     try {\n       while (true) { queue.put(produce()); }\n     } catch (InterruptedException ex) { ... handle ...}\n   }\n   Object produce() { ... }\n }\n\n class Consumer implements Runnable {\n   private final BlockingQueue queue;\n   Consumer(BlockingQueue q) { queue = q; }\n   public void run() {\n     try {\n       while (true) { consume(queue.take()); }\n     } catch (InterruptedException ex) { ... handle ...}\n   }\n   void consume(Object x) { ... }\n }\n\n class Setup {\n   void main() {\n     BlockingQueue q = new SomeQueueImplementation();\n     Producer p = new Producer(q);\n     Consumer c1 = new Consumer(q);\n     Consumer c2 = new Consumer(q);\n     new Thread(p).start();\n     new Thread(c1).start();\n     new Thread(c2).start();\n   }\n } Memory consistency effects: As with other concurrent\n collections, actions in a thread prior to placing an object into a BlockingQueue happen-before actions subsequent to the access or removal of that element from\n the BlockingQueue in another thread. This interface is a member of the Java Collections Framework . Since:",
            "java.util.concurrent.ExecutorService": "ExecutorService (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util.concurrent Interface ExecutorService All Superinterfaces: AutoCloseable , Executor All Known Subinterfaces: ScheduledExecutorService All Known Implementing Classes: AbstractExecutorService , ForkJoinPool , ScheduledThreadPoolExecutor , ThreadPoolExecutor public interface ExecutorService extends Executor , AutoCloseable An Executor that provides methods to manage termination and\n methods that can produce a Future for tracking progress of\n one or more asynchronous tasks. An ExecutorService can be shut down, which will cause\n it to reject new tasks.  Two different methods are provided for\n shutting down an ExecutorService . The shutdown() method will allow previously submitted tasks to execute before\n terminating, while the shutdownNow() method prevents waiting\n tasks from starting and attempts to stop currently executing tasks.\n Upon termination, an executor has no tasks actively executing, no\n tasks awaiting execution, and no new tasks can be submitted.  An\n unused ExecutorService should be shut down to allow\n reclamation of its resources. Method submit extends base method Executor.execute(Runnable) by creating and returning a Future that can be used to cancel execution and/or wait for completion.\n Methods invokeAny and invokeAll perform the most\n commonly useful forms of bulk execution, executing a collection of\n tasks and then waiting for at least one, or all, to\n complete. (Class ExecutorCompletionService can be used to\n write customized variants of these methods.) The Executors class provides factory methods for the\n executor services provided in this package. Usage Examples Here is a sketch of a network service in which threads in a thread\n pool service incoming requests. It uses the preconfigured Executors.newFixedThreadPool(int) factory method: class NetworkService implements Runnable {\n   private final ServerSocket serverSocket;\n   private final ExecutorService pool;\n\n   public NetworkService(int port, int poolSize)\n       throws IOException {\n     serverSocket = new ServerSocket(port);\n     pool = Executors.newFixedThreadPool(poolSize);\n   }\n\n   public void run() { // run the service\n     try {\n       for (;;) {\n         pool.execute(new Handler(serverSocket.accept()));\n       }\n     } catch (IOException ex) {\n       pool.shutdown();\n     }\n   }\n }\n\n class Handler implements Runnable {\n   private final Socket socket;\n   Handler(Socket socket) { this.socket = socket; }\n   public void run() {\n     // read and service request on socket\n   }\n } An ExecutorService may also be established and closed\n (shutdown, blocking until terminated) as follows; illustrating with\n a different Executors factory method: try (ExecutorService e =  Executors.newWorkStealingPool()) {\n   // submit or execute many tasks with e ...\n } Further customization is also possible. For example, the following\n method shuts down an ExecutorService in two phases, first\n by calling shutdown to reject incoming tasks, and then\n calling shutdownNow , if necessary, to cancel any lingering\n tasks: void shutdownAndAwaitTermination(ExecutorService pool) {\n   pool.shutdown(); // Disable new tasks from being submitted\n   try {\n     // Wait a while for existing tasks to terminate\n     if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {\n       pool.shutdownNow(); // Cancel currently executing tasks\n       // Wait a while for tasks to respond to being cancelled\n       if (!pool.awaitTermination(60, TimeUnit.SECONDS))\n           System.err.println(\"Pool did not terminate\");\n     }\n   } catch (InterruptedException ex) {\n     // (Re-)Cancel if current thread also interrupted\n     pool.shutdownNow();\n     // Preserve interrupt status\n     Thread.currentThread().interrupt();\n   }\n } Memory consistency effects: Actions in a thread prior to the\n submission of a Runnable or Callable task to an ExecutorService happen-before any actions taken by that task, which in turn happen-before the\n result is retrieved via Future.get() . Since:",
            "java.util.concurrent.RejectedExecutionException": "RejectedExecutionException (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.util.concurrent Class RejectedExecutionException java.lang.Object java.lang.Throwable java.lang.Exception java.lang.RuntimeException java.util.concurrent.RejectedExecutionException All Implemented Interfaces: Serializable public class RejectedExecutionException extends RuntimeException Exception thrown by an Executor when a task cannot be\n accepted for execution. Since:",
            "java.util.concurrent.ThreadPoolExecutor": "ThreadPoolExecutor (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested | Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.util.concurrent Class ThreadPoolExecutor java.lang.Object java.util.concurrent.AbstractExecutorService java.util.concurrent.ThreadPoolExecutor All Implemented Interfaces: AutoCloseable , Executor , ExecutorService Direct Known Subclasses: ScheduledThreadPoolExecutor public class ThreadPoolExecutor extends AbstractExecutorService An ExecutorService that executes each submitted task using\n one of possibly several pooled threads, normally configured\n using Executors factory methods. Thread pools address two different problems: they usually\n provide improved performance when executing large numbers of\n asynchronous tasks, due to reduced per-task invocation overhead,\n and they provide a means of bounding and managing the resources,\n including threads, consumed when executing a collection of tasks.\n Each ThreadPoolExecutor also maintains some basic\n statistics, such as the number of completed tasks. To be useful across a wide range of contexts, this class\n provides many adjustable parameters and extensibility\n hooks. However, programmers are urged to use the more convenient Executors factory methods Executors.newCachedThreadPool() (unbounded thread pool, with\n automatic thread reclamation), Executors.newFixedThreadPool(int) (fixed size thread pool) and Executors.newSingleThreadExecutor() (single background thread), that\n preconfigure settings for the most common usage\n scenarios. Otherwise, use the following guide when manually\n configuring and tuning this class: Core and maximum pool sizes A ThreadPoolExecutor will automatically adjust the\n pool size (see getPoolSize() )\n according to the bounds set by\n corePoolSize (see getCorePoolSize() ) and\n maximumPoolSize (see getMaximumPoolSize() ).\n\n When a new task is submitted in method execute(Runnable) ,\n if fewer than corePoolSize threads are running, a new thread is\n created to handle the request, even if other worker threads are\n idle.  Else if fewer than maximumPoolSize threads are running, a\n new thread will be created to handle the request only if the queue\n is full.  By setting corePoolSize and maximumPoolSize the same, you\n create a fixed-size thread pool. By setting maximumPoolSize to an\n essentially unbounded value such as Integer.MAX_VALUE , you\n allow the pool to accommodate an arbitrary number of concurrent\n tasks. Most typically, core and maximum pool sizes are set only\n upon construction, but they may also be changed dynamically using setCorePoolSize(int) and setMaximumPoolSize(int) . On-demand construction By default, even core threads are initially created and\n started only when new tasks arrive, but this can be overridden\n dynamically using method prestartCoreThread() or prestartAllCoreThreads() .  You probably want to prestart threads if\n you construct the pool with a non-empty queue. Creating new threads New threads are created using a ThreadFactory .  If not\n otherwise specified, a Executors.defaultThreadFactory() is\n used, that creates threads to all be in the same ThreadGroup and with the same NORM_PRIORITY priority and\n non-daemon status. By supplying a different ThreadFactory, you can\n alter the thread's name, thread group, priority, daemon status,\n etc. If a ThreadFactory fails to create a thread when asked\n by returning null from newThread , the executor will\n continue, but might not be able to execute any tasks. Threads\n should possess the \"modifyThread\" RuntimePermission . If\n worker threads or other threads using the pool do not possess this\n permission, service may be degraded: configuration changes may not\n take effect in a timely manner, and a shutdown pool may remain in a\n state in which termination is possible but not completed. Keep-alive times If the pool currently has more than corePoolSize threads,\n excess threads will be terminated if they have been idle for more\n than the keepAliveTime (see getKeepAliveTime(TimeUnit) ).\n This provides a means of reducing resource consumption when the\n pool is not being actively used. If the pool becomes more active\n later, new threads will be constructed. This parameter can also be\n changed dynamically using method setKeepAliveTime(long, TimeUnit) .  Using a value of Long.MAX_VALUE TimeUnit.NANOSECONDS effectively disables idle threads from ever\n terminating prior to shut down. By default, the keep-alive policy\n applies only when there are more than corePoolSize threads, but\n method allowCoreThreadTimeOut(boolean) can be used to\n apply this time-out policy to core threads as well, so long as the\n keepAliveTime value is non-zero. Queuing Any BlockingQueue may be used to transfer and hold\n submitted tasks.  The use of this queue interacts with pool sizing: If fewer than corePoolSize threads are running, the Executor\n always prefers adding a new thread\n rather than queuing. If corePoolSize or more threads are running, the Executor\n always prefers queuing a request rather than adding a new\n thread. If a request cannot be queued, a new thread is created unless\n this would exceed maximumPoolSize, in which case, the task will be\n rejected. There are three general strategies for queuing: Direct handoffs. A good default choice for a work\n queue is a SynchronousQueue that hands off tasks to threads\n without otherwise holding them. Here, an attempt to queue a task\n will fail if no threads are immediately available to run it, so a\n new thread will be constructed. This policy avoids lockups when\n handling sets of requests that might have internal dependencies.\n Direct handoffs generally require unbounded maximumPoolSizes to\n avoid rejection of new submitted tasks. This in turn admits the\n possibility of unbounded thread growth when commands continue to\n arrive on average faster than they can be processed. Unbounded queues. Using an unbounded queue (for\n example a LinkedBlockingQueue without a predefined\n capacity) will cause new tasks to wait in the queue when all\n corePoolSize threads are busy. Thus, no more than corePoolSize\n threads will ever be created. (And the value of the maximumPoolSize\n therefore doesn't have any effect.)  This may be appropriate when\n each task is completely independent of others, so tasks cannot\n affect each others execution; for example, in a web page server.\n While this style of queuing can be useful in smoothing out\n transient bursts of requests, it admits the possibility of\n unbounded work queue growth when commands continue to arrive on\n average faster than they can be processed. Bounded queues. A bounded queue (for example, an ArrayBlockingQueue ) helps prevent resource exhaustion when\n used with finite maximumPoolSizes, but can be more difficult to\n tune and control.  Queue sizes and maximum pool sizes may be traded\n off for each other: Using large queues and small pools minimizes\n CPU usage, OS resources, and context-switching overhead, but can\n lead to artificially low throughput.  If tasks frequently block (for\n example if they are I/O bound), a system may be able to schedule\n time for more threads than you otherwise allow. Use of small queues\n generally requires larger pool sizes, which keeps CPUs busier but\n may encounter unacceptable scheduling overhead, which also\n decreases throughput. Rejected tasks New tasks submitted in method execute(Runnable) will be rejected when the Executor has been shut down, and also when\n the Executor uses finite bounds for both maximum threads and work queue\n capacity, and is saturated.  In either case, the execute method\n invokes the RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor) method of its RejectedExecutionHandler .  Four predefined handler\n policies are provided: In the default ThreadPoolExecutor.AbortPolicy , the handler\n throws a runtime RejectedExecutionException upon rejection. In ThreadPoolExecutor.CallerRunsPolicy , the thread\n that invokes execute itself runs the task. This provides a\n simple feedback control mechanism that will slow down the rate that\n new tasks are submitted. In ThreadPoolExecutor.DiscardPolicy , a task that cannot\n be executed is simply dropped. This policy is designed only for\n those rare cases in which task completion is never relied upon. In ThreadPoolExecutor.DiscardOldestPolicy , if the\n executor is not shut down, the task at the head of the work queue\n is dropped, and then execution is retried (which can fail again,\n causing this to be repeated.) This policy is rarely acceptable.  In\n nearly all cases, you should also cancel the task to cause an\n exception in any component waiting for its completion, and/or log\n the failure, as illustrated in ThreadPoolExecutor.DiscardOldestPolicy documentation. It is possible to define and use other kinds of RejectedExecutionHandler classes. Doing so requires some care\n especially when policies are designed to work only under particular\n capacity or queuing policies. Hook methods This class provides protected overridable beforeExecute(Thread, Runnable) and afterExecute(Runnable, Throwable) methods that are called\n before and after execution of each task.  These can be used to\n manipulate the execution environment; for example, reinitializing\n ThreadLocals, gathering statistics, or adding log entries.\n Additionally, method terminated() can be overridden to perform\n any special processing that needs to be done once the Executor has\n fully terminated. If hook, callback, or BlockingQueue methods throw exceptions,\n internal worker threads may in turn fail, abruptly terminate, and\n possibly be replaced. Queue maintenance Method getQueue() allows access to the work queue\n for purposes of monitoring and debugging.  Use of this method for\n any other purpose is strongly discouraged.  Two supplied methods, remove(Runnable) and purge() are available to\n assist in storage reclamation when large numbers of queued tasks\n become cancelled. Reclamation A pool that is no longer referenced in a program AND has no remaining threads may be reclaimed (garbage collected)\n without being explicitly shutdown. You can configure a pool to\n allow all unused threads to eventually die by setting appropriate\n keep-alive times, using a lower bound of zero core threads and/or\n setting allowCoreThreadTimeOut(boolean) . Extension example. Most extensions of this class\n override one or more of the protected hook methods. For example,\n here is a subclass that adds a simple pause/resume feature: class PausableThreadPoolExecutor extends ThreadPoolExecutor {\n   private boolean isPaused;\n   private ReentrantLock pauseLock = new ReentrantLock();\n   private Condition unpaused = pauseLock.newCondition();\n\n   public PausableThreadPoolExecutor(...) { super(...); }\n\n   protected void beforeExecute(Thread t, Runnable r) {\n     super.beforeExecute(t, r);\n     pauseLock.lock();\n     try {\n       while (isPaused) unpaused.await();\n     } catch (InterruptedException ie) {\n       t.interrupt();\n     } finally {\n       pauseLock.unlock();\n     }\n   }\n\n   public void pause() {\n     pauseLock.lock();\n     try {\n       isPaused = true;\n     } finally {\n       pauseLock.unlock();\n     }\n   }\n\n   public void resume() {\n     pauseLock.lock();\n     try {\n       isPaused = false;\n       unpaused.signalAll();\n     } finally {\n       pauseLock.unlock();\n     }\n   }\n } Since:",
            "java.util.concurrent.TimeUnit": "TimeUnit (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Enum Constants Field Method Detail: Enum Constants Field Method Summary: Nested | Enum Constants | Field\u00a0| Method Detail: Enum Constants | Field\u00a0| Method SEARCH Module java.base Package java.util.concurrent Enum Class TimeUnit java.lang.Object java.lang.Enum < TimeUnit > java.util.concurrent.TimeUnit All Implemented Interfaces: Serializable , Comparable < TimeUnit > , Constable public enum TimeUnit extends Enum < TimeUnit > A TimeUnit represents time durations at a given unit of\n granularity and provides utility methods to convert across units,\n and to perform timing and delay operations in these units.  A TimeUnit does not maintain time information, but only\n helps organize and use time representations that may be maintained\n separately across various contexts.  A nanosecond is defined as one\n thousandth of a microsecond, a microsecond as one thousandth of a\n millisecond, a millisecond as one thousandth of a second, a minute\n as sixty seconds, an hour as sixty minutes, and a day as twenty four\n hours. A TimeUnit is mainly used to inform time-based methods\n how a given timing parameter should be interpreted. For example,\n the following code will timeout in 50 milliseconds if the lock is not available: Lock lock = ...;\n if (lock.tryLock(50L, TimeUnit.MILLISECONDS)) ... while this code will timeout in 50 seconds: Lock lock = ...;\n if (lock.tryLock(50L, TimeUnit.SECONDS)) ... Note however, that there is no guarantee that a particular timeout\n implementation will be able to notice the passage of time at the\n same granularity as the given TimeUnit . Since:",
            "org.jabref.logic.util.CoarseChangeFilter": null,
            "org.jabref.model.database.BibDatabaseContext": null,
            "org.jabref.model.database.event.AutosaveEvent": null,
            "org.jabref.model.database.event.BibDatabaseContextChangedEvent": null,
            "com.google.common.eventbus.EventBus": null,
            "com.google.common.eventbus.Subscribe": null,
            "org.slf4j.Logger": "Logger (SLF4J javadoc) JavaScript is disabled on your browser. Skip navigation links Overview Package Class Use Tree Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field | Constr\u00a0| Method Detail: Field | Constr\u00a0| Method SEARCH Package org.slf4j Interface Logger All Known Subinterfaces: LocationAwareLogger All Known Implementing Classes: AbstractLogger , EventRecordingLogger , JDK14LoggerAdapter , LegacyAbstractLogger , LocLogger , LoggerWrapper , MarkerIgnoringBase , NOPLogger , Reload4jLoggerAdapter , SimpleLogger , SubstituteLogger , XLogger public interface Logger The org.slf4j.Logger interface is the main user entry point of SLF4J API.\n It is expected that logging takes place through concrete implementations\n of this interface. Typical usage pattern: import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n\n public class Wombat { final static Logger logger = LoggerFactory.getLogger(Wombat.class); Integer t;\n   Integer oldT;\n\n   public void setTemperature(Integer temperature) {\n     oldT = t;\n     t = temperature; logger.debug(\"Temperature set to {}. Old temperature was {}.\", t, oldT); if (temperature.intValue() > 50) { logger.info(\"Temperature has risen above 50 degrees.\"); }\n   }\n } Note that version 2.0 of the SLF4J API introduces a fluent api ,\n the most significant API change to occur in the last 20 years. Be sure to read the FAQ entry relating to parameterized\n logging . Note that logging statements can be parameterized in presence of an exception/throwable . Once you are comfortable using loggers, i.e. instances of this interface, consider using MDC as well as Markers . Author: Ceki G\u00fclc\u00fc Field Summary Fields Modifier and Type Field Description static final String ROOT_LOGGER_NAME Case-insensitive String constant used to retrieve the name of the root logger. Method Summary All Methods Instance Methods Abstract Methods Default Methods Modifier and Type Method Description default LoggingEventBuilder atDebug () Entry point for fluent-logging for Level.DEBUG level. default LoggingEventBuilder atError () Entry point for fluent-logging for Level.ERROR level. default LoggingEventBuilder atInfo () Entry point for fluent-logging for Level.INFO level. default LoggingEventBuilder atLevel ( Level level) Make a new LoggingEventBuilder instance as appropriate for this logger and the\n desired Level passed as parameter. default LoggingEventBuilder atTrace () Entry point for fluent-logging for Level.TRACE level. default LoggingEventBuilder atWarn () Entry point for fluent-logging for Level.WARN level. void debug ( String msg) Log a message at the DEBUG level. void debug ( String format, Object arg) Log a message at the DEBUG level according to the specified format\n and argument. void debug ( String format, Object ...\u00a0arguments) Log a message at the DEBUG level according to the specified format\n and arguments. void debug ( String format, Object arg1, Object arg2) Log a message at the DEBUG level according to the specified format\n and arguments. void debug ( String msg, Throwable t) Log an exception (throwable) at the DEBUG level with an\n accompanying message. void debug ( Marker marker, String msg) Log a message with the specific Marker at the DEBUG level. void debug ( Marker marker, String format, Object arg) This method is similar to debug(String, Object) method except that the\n marker data is also taken into consideration. void debug ( Marker marker, String format, Object ...\u00a0arguments) This method is similar to debug(String, Object...) method except that the marker data is also taken into\n consideration. void debug ( Marker marker, String format, Object arg1, Object arg2) This method is similar to debug(String, Object, Object) method except that the marker data is also taken into\n consideration. void debug ( Marker marker, String msg, Throwable t) This method is similar to debug(String, Throwable) method except that the\n marker data is also taken into consideration. void error ( String msg) Log a message at the ERROR level. void error ( String format, Object arg) Log a message at the ERROR level according to the specified format\n and argument. void error ( String format, Object ...\u00a0arguments) Log a message at the ERROR level according to the specified format\n and arguments. void error ( String format, Object arg1, Object arg2) Log a message at the ERROR level according to the specified format\n and arguments. void error ( String msg, Throwable t) Log an exception (throwable) at the ERROR level with an\n accompanying message. void error ( Marker marker, String msg) Log a message with the specific Marker at the ERROR level. void error ( Marker marker, String format, Object arg) This method is similar to error(String, Object) method except that the\n marker data is also taken into consideration. void error ( Marker marker, String format, Object ...\u00a0arguments) This method is similar to error(String, Object...) method except that the marker data is also taken into\n consideration. void error ( Marker marker, String format, Object arg1, Object arg2) This method is similar to error(String, Object, Object) method except that the marker data is also taken into\n consideration. void error ( Marker marker, String msg, Throwable t) This method is similar to error(String, Throwable) method except that the marker data is also taken into\n consideration. String getName () Return the name of this Logger instance. void info ( String msg) Log a message at the INFO level. void info ( String format, Object arg) Log a message at the INFO level according to the specified format\n and argument. void info ( String format, Object ...\u00a0arguments) Log a message at the INFO level according to the specified format\n and arguments. void info ( String format, Object arg1, Object arg2) Log a message at the INFO level according to the specified format\n and arguments. void info ( String msg, Throwable t) Log an exception (throwable) at the INFO level with an\n accompanying message. void info ( Marker marker, String msg) Log a message with the specific Marker at the INFO level. void info ( Marker marker, String format, Object arg) This method is similar to info(String, Object) method except that the\n marker data is also taken into consideration. void info ( Marker marker, String format, Object ...\u00a0arguments) This method is similar to info(String, Object...) method except that the marker data is also taken into\n consideration. void info ( Marker marker, String format, Object arg1, Object arg2) This method is similar to info(String, Object, Object) method except that the marker data is also taken into\n consideration. void info ( Marker marker, String msg, Throwable t) This method is similar to info(String, Throwable) method\n except that the marker data is also taken into consideration. boolean isDebugEnabled () Is the logger instance enabled for the DEBUG level? boolean isDebugEnabled ( Marker marker) Similar to isDebugEnabled() method except that the\n marker data is also taken into account. default boolean isEnabledForLevel ( Level level) Returns whether this Logger is enabled for a given Level . boolean isErrorEnabled () Is the logger instance enabled for the ERROR level? boolean isErrorEnabled ( Marker marker) Similar to isErrorEnabled() method except that the\n marker data is also taken into consideration. boolean isInfoEnabled () Is the logger instance enabled for the INFO level? boolean isInfoEnabled ( Marker marker) Similar to isInfoEnabled() method except that the marker\n data is also taken into consideration. boolean isTraceEnabled () Is the logger instance enabled for the TRACE level? boolean isTraceEnabled ( Marker marker) Similar to isTraceEnabled() method except that the\n marker data is also taken into account. boolean isWarnEnabled () Is the logger instance enabled for the WARN level? boolean isWarnEnabled ( Marker marker) Similar to isWarnEnabled() method except that the marker\n data is also taken into consideration. default LoggingEventBuilder makeLoggingEventBuilder ( Level level) Make a new LoggingEventBuilder instance as appropriate for this logger implementation. void trace ( String msg) Log a message at the TRACE level. void trace ( String format, Object arg) Log a message at the TRACE level according to the specified format\n and argument. void trace ( String format, Object ...\u00a0arguments) Log a message at the TRACE level according to the specified format\n and arguments. void trace ( String format, Object arg1, Object arg2) Log a message at the TRACE level according to the specified format\n and arguments. void trace ( String msg, Throwable t) Log an exception (throwable) at the TRACE level with an\n accompanying message. void trace ( Marker marker, String msg) Log a message with the specific Marker at the TRACE level. void trace ( Marker marker, String format, Object arg) This method is similar to trace(String, Object) method except that the\n marker data is also taken into consideration. void trace ( Marker marker, String format, Object ...\u00a0argArray) This method is similar to trace(String, Object...) method except that the marker data is also taken into\n consideration. void trace ( Marker marker, String format, Object arg1, Object arg2) This method is similar to trace(String, Object, Object) method except that the marker data is also taken into\n consideration. void trace ( Marker marker, String msg, Throwable t) This method is similar to trace(String, Throwable) method except that the\n marker data is also taken into consideration. void warn ( String msg) Log a message at the WARN level. void warn ( String format, Object arg) Log a message at the WARN level according to the specified format\n and argument. void warn ( String format, Object ...\u00a0arguments) Log a message at the WARN level according to the specified format\n and arguments. void warn ( String format, Object arg1, Object arg2) Log a message at the WARN level according to the specified format\n and arguments. void warn ( String msg, Throwable t) Log an exception (throwable) at the WARN level with an\n accompanying message. void warn ( Marker marker, String msg) Log a message with the specific Marker at the WARN level. void warn ( Marker marker, String format, Object arg) This method is similar to warn(String, Object) method except that the\n marker data is also taken into consideration. void warn ( Marker marker, String format, Object ...\u00a0arguments) This method is similar to warn(String, Object...) method except that the marker data is also taken into\n consideration. void warn ( Marker marker, String format, Object arg1, Object arg2) This method is similar to warn(String, Object, Object) method except that the marker data is also taken into\n consideration. void warn ( Marker marker, String msg, Throwable t) This method is similar to warn(String, Throwable) method\n except that the marker data is also taken into consideration. Field Details ROOT_LOGGER_NAME static final String ROOT_LOGGER_NAME Case-insensitive String constant used to retrieve the name of the root logger. Since:",
            "org.slf4j.LoggerFactory": "LoggerFactory (SLF4J javadoc) JavaScript is disabled on your browser. Skip navigation links Overview Package Class Use Tree Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field | Constr\u00a0| Method Detail: Field | Constr\u00a0| Method SEARCH Package org.slf4j Class LoggerFactory java.lang.Object org.slf4j.LoggerFactory public final class LoggerFactory extends Object The LoggerFactory is a utility class producing Loggers for\n various logging APIs, e.g. logback, reload4j, log4j and JDK 1.4 logging.\n Other implementations such as NOPLogger and\n SimpleLogger are also supported. LoggerFactory is essentially a wrapper around an ILoggerFactory instance provided by a SLF4JServiceProvider . Please note that all methods in LoggerFactory are static. Author: Alexander Dorokhine, Robert Elliot, Ceki G\u00fclc\u00fc Field Summary Fields Modifier and Type Field Description static final String PROVIDER_PROPERTY_KEY System property for explicitly setting the provider class. Method Summary All Methods Static Methods Concrete Methods Modifier and Type Method Description static ILoggerFactory getILoggerFactory () Return the ILoggerFactory instance in use. static Logger getLogger ( Class <?>\u00a0clazz) Return a logger named corresponding to the class passed as parameter,\n using the statically bound ILoggerFactory instance. static Logger getLogger ( String name) Return a logger named according to the name parameter using the\n statically bound ILoggerFactory instance. Methods inherited from class\u00a0java.lang. Object clone , equals , finalize , getClass , hashCode , notify , notifyAll , toString , wait , wait , wait Field Details PROVIDER_PROPERTY_KEY public static final String PROVIDER_PROPERTY_KEY System property for explicitly setting the provider class. If set and the provider could be instantiated,\n then the service loading mechanism will be bypassed. Since:"
        },
        "classes_labeled": {
            "autosaveandbackup": "Utility",
            "HashSet": "Data Structure",
            "Set": "Data Structure",
            "ArrayBlockingQueue": "Data Structure",
            "BlockingQueue": "Data Structure",
            "ExecutorService": "Multi-Thread",
            "RejectedExecutionException": "Error Handling",
            "ThreadPoolExecutor": "Multi-Thread",
            "TimeUnit": "Utility",
            "CoarseChangeFilter": "Data Structure",
            "BibDatabaseContext": "Data Structure",
            "AutosaveEvent": "Event Handling",
            "BibDatabaseContextChangedEvent": "Event Handling",
            "EventBus": "Event Handling",
            "Subscribe": "User Interface",
            "Logger": "Logging",
            "LoggerFactory": "Logging"
        },
        "function_summaries": {
            "getLogger": "Logging",
            "registerListener": "Callback",
            "SECONDS": "Operation",
            "submit": "Operation",
            "post": "Operation",
            "debug": "Logging",
            "unregisterListener": "Callback",
            "shutdown": "Cleanup",
            "add": "Integration",
            "stream": "Iteration",
            "filter": "Filter",
            "findAny": "Iteration",
            "ifPresent": "Operation",
            "remove": "Deletion",
            "register": "Mapping",
            "unregister": "Callback",
            "getFirstExistingFileDir": "Operation",
            "resolve": "Integration",
            "orElse": "Integration",
            "getFileDirectories": "Integration",
            "error": "Error Handling"
        },
        "functions_labeled": {
            "getLogger": "Logging",
            "registerListener": "Callback",
            "SECONDS": "Operation",
            "submit": "Operation",
            "post": "Operation",
            "debug": "Logging",
            "unregisterListener": "Callback",
            "shutdown": "Cleanup",
            "add": "Integration",
            "stream": "Iteration",
            "filter": "Filter",
            "findAny": "Iteration",
            "ifPresent": "Operation",
            "remove": "Deletion",
            "register": "Mapping",
            "unregister": "Callback",
            "getFirstExistingFileDir": "Operation",
            "resolve": "Integration",
            "orElse": "Integration",
            "getFileDirectories": "Integration",
            "error": "Error Handling"
        }
    },
    "BindingHelper": {
        "imports_documentation": {
            "org.jabref.gui.util": null,
            "com.tobiasdiez.easybind.EasyBind": null,
            "com.tobiasdiez.easybind.PreboundBinding": null,
            "com.tobiasdiez.easybind.Subscription": null,
            "javafx.beans.binding.BooleanBinding": "BooleanBinding (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module javafx.base Package javafx.beans.binding Class BooleanBinding java.lang.Object javafx.beans.binding.BooleanExpression javafx.beans.binding.BooleanBinding All Implemented Interfaces: Binding < Boolean > , Observable , ObservableBooleanValue , ObservableValue < Boolean > public abstract class BooleanBinding extends BooleanExpression implements Binding < Boolean > Base class that provides most of the functionality needed to implement a Binding of a boolean value. BooleanBinding provides a simple invalidation-scheme. An extending\n class can register dependencies by calling bind(Observable...) .\n If One of the registered dependencies becomes invalid, this BooleanBinding is marked as invalid. With unbind(Observable...) listening to dependencies can be stopped. To provide a concrete implementation of this class, the method computeValue() has to be implemented to calculate the value of this\n binding based on the current state of the dependencies. It is called when get() is called for an invalid binding. See DoubleBinding for an example how this base class can be extended. Since:",
            "javafx.beans.binding.ObjectBinding": "ObjectBinding (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module javafx.base Package javafx.beans.binding Class ObjectBinding<T> java.lang.Object javafx.beans.binding.ObjectExpression <T> javafx.beans.binding.ObjectBinding<T> Type Parameters: T - the type of the wrapped Object All Implemented Interfaces: Binding <T> , Observable , ObservableObjectValue <T> , ObservableValue <T> public abstract class ObjectBinding<T> extends ObjectExpression <T>\nimplements Binding <T> Base class that provides most of the functionality needed to implement a Binding of an Object . ObjectBinding provides a simple invalidation-scheme. An extending\n class can register dependencies by calling bind(Observable...) .\n If One of the registered dependencies becomes invalid, this ObjectBinding is marked as invalid. With unbind(Observable...) listening to dependencies can be stopped. To provide a concrete implementation of this class, the method computeValue() has to be implemented to calculate the value of this\n binding based on the current state of the dependencies. It is called when get() is called for an invalid binding. See DoubleBinding for an example how this base class can be extended. Since:",
            "javafx.beans.binding.StringBinding": "StringBinding (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module javafx.base Package javafx.beans.binding Class StringBinding java.lang.Object javafx.beans.binding.StringExpression javafx.beans.binding.StringBinding All Implemented Interfaces: Binding < String > , Observable , ObservableObjectValue < String > , ObservableStringValue , ObservableValue < String > public abstract class StringBinding extends StringExpression implements Binding < String > Base class that provides most of the functionality needed to implement a Binding of a String . StringBinding provides a simple invalidation-scheme. An extending\n class can register dependencies by calling bind(Observable...) .\n If One of the registered dependencies becomes invalid, this StringBinding is marked as invalid. With unbind(Observable...) listening to dependencies can be stopped. To provide a concrete implementation of this class, the method computeValue() has to be implemented to calculate the value of this\n binding based on the current state of the dependencies. It is called when get() is called for an invalid binding. See DoubleBinding for an example how this base class can be extended. Since:",
            "javafx.beans.property.ListProperty": "ListProperty (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module javafx.base Package javafx.beans.property Class ListProperty<E> java.lang.Object javafx.beans.binding.ListExpression <E> javafx.beans.property.ReadOnlyListProperty <E> javafx.beans.property.ListProperty<E> Type Parameters: E - the type of the List elements All Implemented Interfaces: Iterable <E> , Collection <E> , List <E> , Observable , Property < ObservableList <E>> , ReadOnlyProperty < ObservableList <E>> , ObservableListValue <E> , ObservableObjectValue < ObservableList <E>> , ObservableValue < ObservableList <E>> , WritableListValue <E> , WritableObjectValue < ObservableList <E>> , WritableValue < ObservableList <E>> , ObservableList <E> Direct Known Subclasses: ListPropertyBase public abstract class ListProperty<E> extends ReadOnlyListProperty <E>\nimplements Property < ObservableList <E>>, WritableListValue <E> This class provides a full implementation of a Property wrapping an ObservableList .\n\n The value of a ListProperty can be get and set with ObservableObjectValue.get() , ListExpression.getValue() , WritableObjectValue.set(Object) , and setValue(ObservableList) .\n\n A property can be bound and unbound unidirectional with Property.bind(javafx.beans.value.ObservableValue) and Property.unbind() . Bidirectional bindings\n can be created and removed with bindBidirectional(Property) and unbindBidirectional(Property) .\n\n The context of a ListProperty can be read with ReadOnlyProperty.getBean() and ReadOnlyProperty.getName() . Since:",
            "javafx.beans.property.Property": "Property (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module javafx.base Package javafx.beans.property Interface Property<T> Type Parameters: T - the type of the wrapped value All Superinterfaces: Observable , ObservableValue <T> , ReadOnlyProperty <T> , WritableValue <T> All Known Subinterfaces: JavaBeanProperty <T> All Known Implementing Classes: BooleanProperty , BooleanPropertyBase , DoubleProperty , DoublePropertyBase , FloatProperty , FloatPropertyBase , IntegerProperty , IntegerPropertyBase , JavaBeanBooleanProperty , JavaBeanDoubleProperty , JavaBeanFloatProperty , JavaBeanIntegerProperty , JavaBeanLongProperty , JavaBeanObjectProperty , JavaBeanStringProperty , ListProperty , ListPropertyBase , LongProperty , LongPropertyBase , MapProperty , MapPropertyBase , ObjectProperty , ObjectPropertyBase , ReadOnlyBooleanWrapper , ReadOnlyDoubleWrapper , ReadOnlyFloatWrapper , ReadOnlyIntegerWrapper , ReadOnlyListWrapper , ReadOnlyLongWrapper , ReadOnlyMapWrapper , ReadOnlyObjectWrapper , ReadOnlySetWrapper , ReadOnlyStringWrapper , SetProperty , SetPropertyBase , SimpleBooleanProperty , SimpleDoubleProperty , SimpleFloatProperty , SimpleIntegerProperty , SimpleListProperty , SimpleLongProperty , SimpleMapProperty , SimpleObjectProperty , SimpleSetProperty , SimpleStringProperty , SimpleStyleableBooleanProperty , SimpleStyleableDoubleProperty , SimpleStyleableFloatProperty , SimpleStyleableIntegerProperty , SimpleStyleableLongProperty , SimpleStyleableObjectProperty , SimpleStyleableStringProperty , StringProperty , StringPropertyBase , StyleableBooleanProperty , StyleableDoubleProperty , StyleableFloatProperty , StyleableIntegerProperty , StyleableLongProperty , StyleableObjectProperty , StyleableStringProperty public interface Property<T> extends ReadOnlyProperty <T>, WritableValue <T> Generic interface that defines the methods common to all (writable)\n properties, independent of their type. Since:",
            "javafx.beans.value.ChangeListener": "ChangeListener (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module javafx.base Package javafx.beans.value Interface ChangeListener<T> All Known Implementing Classes: WeakChangeListener Functional Interface: This is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference. @FunctionalInterface public interface ChangeListener<T> A ChangeListener is notified whenever the value of an ObservableValue changes. It can be registered and unregistered with ObservableValue.addListener(ChangeListener) respectively ObservableValue.removeListener(ChangeListener) For an in-depth explanation of change events and how they differ from\n invalidation events, see the documentation of ObservableValue . The same instance of ChangeListener can be registered to listen to\n multiple ObservableValues . Since:",
            "javafx.beans.value.ObservableValue": "ObservableValue (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module javafx.base Package javafx.beans.value Interface ObservableValue<T> Type Parameters: T - The type of the wrapped value. All Superinterfaces: Observable All Known Subinterfaces: Binding <T> , JavaBeanProperty <T> , NumberBinding , NumberExpression , ObservableBooleanValue , ObservableDoubleValue , ObservableFloatValue , ObservableIntegerValue , ObservableListValue <E> , ObservableLongValue , ObservableMapValue <K, V> , ObservableNumberValue , ObservableObjectValue <T> , ObservableSetValue <E> , ObservableStringValue , Property <T> , ReadOnlyJavaBeanProperty <T> , ReadOnlyProperty <T> , TextInputControl.Content All Known Implementing Classes: BooleanBinding , BooleanExpression , BooleanProperty , BooleanPropertyBase , DoubleBinding , DoubleExpression , DoubleProperty , DoublePropertyBase , FloatBinding , FloatExpression , FloatProperty , FloatPropertyBase , IntegerBinding , IntegerExpression , IntegerProperty , IntegerPropertyBase , JavaBeanBooleanProperty , JavaBeanDoubleProperty , JavaBeanFloatProperty , JavaBeanIntegerProperty , JavaBeanLongProperty , JavaBeanObjectProperty , JavaBeanStringProperty , ListBinding , ListExpression , ListProperty , ListPropertyBase , LongBinding , LongExpression , LongProperty , LongPropertyBase , MapBinding , MapExpression , MapProperty , MapPropertyBase , NumberExpressionBase , ObjectBinding , ObjectExpression , ObjectProperty , ObjectPropertyBase , ObservableValueBase , ReadOnlyBooleanProperty , ReadOnlyBooleanPropertyBase , ReadOnlyBooleanWrapper , ReadOnlyDoubleProperty , ReadOnlyDoublePropertyBase , ReadOnlyDoubleWrapper , ReadOnlyFloatProperty , ReadOnlyFloatPropertyBase , ReadOnlyFloatWrapper , ReadOnlyIntegerProperty , ReadOnlyIntegerPropertyBase , ReadOnlyIntegerWrapper , ReadOnlyJavaBeanBooleanProperty , ReadOnlyJavaBeanDoubleProperty , ReadOnlyJavaBeanFloatProperty , ReadOnlyJavaBeanIntegerProperty , ReadOnlyJavaBeanLongProperty , ReadOnlyJavaBeanObjectProperty , ReadOnlyJavaBeanStringProperty , ReadOnlyListProperty , ReadOnlyListPropertyBase , ReadOnlyListWrapper , ReadOnlyLongProperty , ReadOnlyLongPropertyBase , ReadOnlyLongWrapper , ReadOnlyMapProperty , ReadOnlyMapPropertyBase , ReadOnlyMapWrapper , ReadOnlyObjectProperty , ReadOnlyObjectPropertyBase , ReadOnlyObjectWrapper , ReadOnlySetProperty , ReadOnlySetPropertyBase , ReadOnlySetWrapper , ReadOnlyStringProperty , ReadOnlyStringPropertyBase , ReadOnlyStringWrapper , SetBinding , SetExpression , SetProperty , SetPropertyBase , SimpleBooleanProperty , SimpleDoubleProperty , SimpleFloatProperty , SimpleIntegerProperty , SimpleListProperty , SimpleLongProperty , SimpleMapProperty , SimpleObjectProperty , SimpleSetProperty , SimpleStringProperty , SimpleStyleableBooleanProperty , SimpleStyleableDoubleProperty , SimpleStyleableFloatProperty , SimpleStyleableIntegerProperty , SimpleStyleableLongProperty , SimpleStyleableObjectProperty , SimpleStyleableStringProperty , StringBinding , StringExpression , StringProperty , StringPropertyBase , StyleableBooleanProperty , StyleableDoubleProperty , StyleableFloatProperty , StyleableIntegerProperty , StyleableLongProperty , StyleableObjectProperty , StyleableStringProperty public interface ObservableValue<T> extends Observable An ObservableValue is an entity that wraps a value and allows to\n observe the value for changes. In general this interface should not be\n implemented directly but one of its sub-interfaces\n ( ObservableBooleanValue etc.). The value of the ObservableValue can be requested with getValue() . An implementation of ObservableValue may support lazy evaluation,\n which means that the value is not immediately recomputed after changes, but\n lazily the next time the value is requested (see note 1 in \"Implementation Requirements\"). An ObservableValue generates two types of events: change events and\n invalidation events. A change event indicates that the value has changed\n (see note 2 in \"Implementation Requirements\"). An\n invalidation event is generated if the current value is not valid anymore.\n This distinction becomes important if the ObservableValue supports\n lazy evaluation, because for a lazily evaluated value one does not know if an\n invalid value really has changed until it is recomputed. For this reason,\n generating change events requires eager evaluation while invalidation events\n can be generated for eager and lazy implementations. Implementations of this class should strive to generate as few events as\n possible to avoid wasting too much time in event handlers. Implementations in\n this library mark themselves as invalid when the first invalidation event\n occurs. They do not generate any more invalidation events until their value is\n recomputed and valid again. Two types of listeners can be attached to an ObservableValue : InvalidationListener to listen to invalidation events and ChangeListener to listen to change events. Important note: attaching a ChangeListener enforces eager computation\n even if the implementation of the ObservableValue supports lazy\n evaluation. Implementation Requirements: All bindings and properties in the JavaFX library support lazy evaluation. All implementing classes in the JavaFX library check for a change using reference\n equality (and not object equality, Object#equals(Object) ) of the value. Since:",
            "javafx.collections.*": null,
            "javafx.css.PseudoClass": "PseudoClass (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module javafx.graphics Package javafx.css Class PseudoClass java.lang.Object javafx.css.PseudoClass public abstract class PseudoClass extends Object PseudoClass represents one unique pseudo-class state. Introducing a\n pseudo-class into a JavaFX class only requires that the method Node.pseudoClassStateChanged(javafx.css.PseudoClass, boolean) be called when the pseudo-class state changes. Typically, the pseudoClassStateChanged method is called from the protected void invalidated() method of one of the property base\n classes in the javafx.beans.property package. Note that if a node has a default pseudo-class state, a horizontal orientation\n for example, pseudoClassStateChanged should be called from the\n constructor to set the initial state. The following example would allow \"xyzzy\" to be used as a\n  pseudo-class in a CSS selector. public boolean isMagic() {\n       return magic.get();\n   }\n\n   public BooleanProperty magicProperty() {\n       return magic;\n   }\n\n   public BooleanProperty magic =\n       new BooleanPropertyBase(false) {\n\n       @Override protected void invalidated() {\n           pseudoClassStateChanged(MAGIC_PSEUDO_CLASS, get());\n       }\n\n       @Override public Object getBean() {\n           return MyControl.this;\n       }\n\n       @Override public String getName() {\n           return \"magic\";\n       }\n   }\n\n   private static final PseudoClass\n       MAGIC_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"xyzzy\"); Since:",
            "javafx.scene.Node": "Node (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field | Constr | Method Detail: Field | Constr | Method SEARCH Module javafx.graphics Package javafx.scene Class Node java.lang.Object javafx.scene.Node All Implemented Interfaces: Styleable , EventTarget Direct Known Subclasses: Camera , Canvas , ImageView , LightBase , MediaView , Parent , Shape , Shape3D , SubScene , SwingNode @IDProperty(\"id\") public abstract class Node extends Object implements EventTarget , Styleable Base class for scene graph nodes. A scene graph is a set of tree data structures\n where every item has zero or one parent, and each item is either\n a \"leaf\" with zero sub-items or a \"branch\" with zero or more sub-items. Each item in the scene graph is called a Node . Branch nodes are\n of type Parent , whose concrete subclasses are Group , Region , and Control ,\n or subclasses thereof. Leaf nodes are classes such as Rectangle , Text , ImageView , MediaView ,\n or other such leaf classes which cannot have children. Only a single node within\n each scene graph tree will have no parent, which is referred to as the \"root\" node. There may be several trees in the scene graph. Some trees may be part of\n a Scene , in which case they are eligible to be displayed.\n Other trees might not be part of any Scene . A node may occur at most once anywhere in the scene graph. Specifically,\n a node must appear no more than once in all of the following:\n as the root node of a Scene ,\n the children ObservableList of a Parent ,\n or as the clip of a Node . The scene graph must not have cycles. A cycle would exist if a node is\n an ancestor of itself in the tree, considering the Group content\n ObservableList, Parent children ObservableList, and Node clip relationships\n mentioned above. If a program adds a child node to a Parent (including Group, Region, etc)\n and that node is already a child of a different Parent or the root of a Scene,\n the node is automatically (and silently) removed from its former parent.\n If a program attempts to modify the scene graph in any other way that violates\n the above rules, an exception is thrown, the modification attempt is ignored\n and the scene graph is restored to its previous state. It is possible to rearrange the structure of the scene graph, for\n example, to move a subtree from one location in the scene graph to\n another. In order to do this, one would normally remove the subtree from\n its old location before inserting it at the new location. However, the\n subtree will be automatically removed as described above if the application\n doesn't explicitly remove it. Node objects may be constructed and modified on any thread as long they are\n not yet attached to a Scene in a Window that is showing .\n An application must attach nodes to such a Scene or modify them on the JavaFX\n Application Thread. The JavaFX Application Thread is created as part of the startup process for\n the JavaFX runtime. See the Application class and\n the Platform.startup(Runnable) method for more information. An application should not extend the Node class directly. Doing so may lead to\n an UnsupportedOperationException being thrown. String ID Each node in the scene graph can be given a unique id . This id is\n much like the \"id\" attribute of an HTML tag in that it is up to the designer\n and developer to ensure that the id is unique within the scene graph.\n A convenience function called lookup(String) can be used to find\n a node with a unique id within the scene graph, or within a subtree of the\n scene graph. The id can also be used identify nodes for applying styles; see\n the CSS section below. Coordinate System The Node class defines a traditional computer graphics \"local\"\n coordinate system in which the x axis increases to the right and the y axis increases downwards.  The concrete node classes for shapes\n provide variables for defining the geometry and location of the shape\n within this local coordinate space.  For example, Rectangle provides x , y , width , height variables while Circle provides centerX , centerY ,\n and radius . At the device pixel level, integer coordinates map onto the corners and\n cracks between the pixels and the centers of the pixels appear at the\n midpoints between integer pixel locations.  Because all coordinate values\n are specified with floating point numbers, coordinates can precisely\n point to these corners (when the floating point values have exact integer\n values) or to any location on the pixel.  For example, a coordinate of (0.5, 0.5) would point to the center of the upper left pixel on the Stage .  Similarly, a rectangle at (0, 0) with dimensions\n of 10 by 10 would span from the upper left corner of the\n upper left pixel on the Stage to the lower right corner of the\n 10th pixel on the 10th scanline.  The pixel center of the last pixel\n inside that rectangle would be at the coordinates (9.5, 9.5) . In practice, most nodes have transformations applied to their coordinate\n system as mentioned below.  As a result, the information above describing\n the alignment of device coordinates to the pixel grid is relative to\n the transformed coordinates, not the local coordinates of the nodes.\n The Shape class describes some additional\n important context-specific information about coordinate mapping and how\n it can affect rendering. Transformations Any Node can have transformations applied to it. These include\n translation, rotation, scaling, or shearing. A translation transformation is one which shifts the origin of the\n node's coordinate space along either the x or y axis. For example, if you\n create a Rectangle which is drawn at the origin\n (x=0, y=0) and has a width of 100 and a height of 50, and then apply a Translate with a shift of 10 along the x axis\n (x=10), then the rectangle will appear drawn at (x=10, y=0) and remain\n 100 points wide and 50 tall. Note that the origin was shifted, not the x variable of the rectangle. A common node transform is a translation by an integer distance, most often\n used to lay out nodes on the stage.  Such integer translations maintain the\n device pixel mapping so that local coordinates that are integers still\n map to the cracks between pixels. A rotation transformation is one which rotates the coordinate space of\n the node about a specified \"pivot\" point, causing the node to appear rotated.\n For example, if you create a Rectangle which is\n drawn at the origin (x=0, y=0) and has a width of 100 and height of 30 and\n you apply a Rotate with a 90 degree rotation\n (angle=90) and a pivot at the origin (pivotX=0, pivotY=0), then\n the rectangle will be drawn as if its x and y were zero but its height was\n 100 and its width -30. That is, it is as if a pin is being stuck at the top\n left corner and the rectangle is rotating 90 degrees clockwise around that\n pin. If the pivot point is instead placed in the center of the rectangle\n (at point x=50, y=15) then the rectangle will instead appear to rotate about\n its center. Note that as with all transformations, the x, y, width, and height variables\n of the rectangle (which remain relative to the local coordinate space) have\n not changed, but rather the transformation alters the entire coordinate space\n of the rectangle. A scaling transformation causes a node to either appear larger or\n smaller depending on the scaling factor. Scaling alters the coordinate space\n of the node such that each unit of distance along the axis in local\n coordinates is multiplied by the scale factor. As with rotation\n transformations, scaling transformations are applied about a \"pivot\" point.\n You can think of this as the point in the Node around which you \"zoom\".  For\n example, if you create a Rectangle with a strokeWidth of 5, and a width and height of 50, and you apply a Scale with scale factors (x=2.0, y=2.0) and\n a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle\n (including the stroke) will double in size, growing to the right and\n downwards from the origin. A shearing transformation, sometimes called a skew, effectively\n rotates one axis so that the x and y axes are no longer perpendicular. Multiple transformations may be applied to a node. Custom transforms are applied using the transforms list. Predefined transforms are applied using the properties specified below.\n The matrices that represent the transforms are multiplied in this order: Layout ( layoutX , layoutY ) and translate\n ( translateX , translateY , translateZ ) Rotate ( rotate ) Scale ( scaleX , scaleY , scaleZ ) Transforms list ( transforms ) starting from element 0 The transforms are applied in the reverse order of the matrix multiplication outlined above: last element of the transforms list\n to 0th element, scale, rotate, and layout and translate. By applying the transforms in this order, the bounds in the local\n coordinates of the node are transformed to the bounds in the parent coordinate of the node (see the Bounding Rectangles section). Bounding Rectangles Since every",
            "java.util.List": "List (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util Interface List<E> Type Parameters: E - the type of elements in this list All Superinterfaces: Collection <E> , Iterable <E> , SequencedCollection <E> All Known Implementing Classes: AbstractList , AbstractSequentialList , ArrayList , AttributeList , CopyOnWriteArrayList , LinkedList , RoleList , RoleUnresolvedList , Stack , Vector public interface List<E> extends SequencedCollection <E> An ordered collection, where the user has precise control over where in the\n list each element is inserted.  The user can access elements by their integer\n index (position in the list), and search for elements in the list. Unlike sets, lists typically allow duplicate elements.  More formally,\n lists typically allow pairs of elements e1 and e2 such that e1.equals(e2) , and they typically allow multiple\n null elements if they allow null elements at all.  It is not inconceivable\n that someone might wish to implement a list that prohibits duplicates, by\n throwing runtime exceptions when the user attempts to insert them, but we\n expect this usage to be rare. The List interface places additional stipulations, beyond those\n specified in the Collection interface, on the contracts of the iterator , add , remove , equals , and hashCode methods.  Declarations for other inherited methods are\n also included here for convenience. The List interface provides four methods for positional (indexed)\n access to list elements.  Lists (like Java arrays) are zero based.  Note\n that these operations may execute in time proportional to the index value\n for some implementations (the LinkedList class, for\n example). Thus, iterating over the elements in a list is typically\n preferable to indexing through it if the caller does not know the\n implementation. The List interface provides a special iterator, called a ListIterator , that allows element insertion and replacement, and\n bidirectional access in addition to the normal operations that the Iterator interface provides.  A method is provided to obtain a\n list iterator that starts at a specified position in the list. The List interface provides two methods to search for a specified\n object.  From a performance standpoint, these methods should be used with\n caution.  In many implementations they will perform costly linear\n searches. The List interface provides two methods to efficiently insert and\n remove multiple elements at an arbitrary point in the list. Note: While it is permissible for lists to contain themselves as elements,\n extreme caution is advised: the equals and hashCode methods are no longer well defined on such a list. Some list implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException .  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the list may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface. Unmodifiable Lists The List.of and List.copyOf static factory methods\n provide a convenient way to create unmodifiable lists. The List instances created by these methods have the following characteristics: They are unmodifiable . Elements cannot\n be added, removed, or replaced. Calling any mutator method on the List\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained elements are themselves mutable,\n this may cause the List's contents to appear to change. They disallow null elements. Attempts to create them with null elements result in NullPointerException . They are serializable if all elements are serializable. The order of elements in the list is the same as the order of the\n provided arguments, or of the elements in the provided array. The lists and their subList views implement the RandomAccess interface. They are value-based .\n Programmers should treat instances that are equal as interchangeable and should not use them for synchronization, or\n unpredictable behavior may occur. For example, in a future release,\n synchronization may fail. Callers should make no assumptions about the\n identity of the returned instances. Factories are free to\n create new instances or reuse existing ones. They are serialized as specified on the Serialized Form page. This interface is a member of the Java Collections Framework . Since:",
            "java.util.Map": "Map (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested | Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util Interface Map<K, V> Type Parameters: K - the type of keys maintained by this map V - the type of mapped values All Known Subinterfaces: Bindings , ConcurrentMap <K, V> , ConcurrentNavigableMap <K, V> , NavigableMap <K, V> , SequencedMap <K, V> , SortedMap <K, V> All Known Implementing Classes: AbstractMap , Attributes , AuthProvider , ConcurrentHashMap , ConcurrentSkipListMap , EnumMap , HashMap , Hashtable , Headers , IdentityHashMap , LinkedHashMap , PrinterStateReasons , Properties , Provider , RenderingHints , SimpleBindings , TabularDataSupport , TreeMap , UIDefaults , WeakHashMap public interface Map<K, V> An object that maps keys to values.  A map cannot contain duplicate keys;\n each key can map to at most one value. This interface takes the place of the Dictionary class, which\n was a totally abstract class rather than an interface. The Map interface provides three collection views , which\n allow a map's contents to be viewed as a set of keys, collection of values,\n or set of key-value mappings.  The order of a map is defined as\n the order in which the iterators on the map's collection views return their\n elements.  Some map implementations, like the TreeMap class, make\n specific guarantees as to their encounter order; others, like the HashMap class, do not. Maps with a defined encounter order are generally subtypes of the SequencedMap interface. Note: great care must be exercised if mutable objects are used as map\n keys.  The behavior of a map is not specified if the value of an object is\n changed in a manner that affects equals comparisons while the\n object is a key in the map.  A special case of this prohibition is that it\n is not permissible for a map to contain itself as a key.  While it is\n permissible for a map to contain itself as a value, extreme caution is\n advised: the equals and hashCode methods are no longer\n well defined on such a map. All general-purpose map implementation classes should provide two\n \"standard\" constructors: a void (no arguments) constructor which creates an\n empty map, and a constructor with a single argument of type Map ,\n which creates a new map with the same key-value mappings as its argument.\n In effect, the latter constructor allows the user to copy any map,\n producing an equivalent map of the desired class.  There is no way to\n enforce this recommendation (as interfaces cannot contain constructors) but\n all of the general-purpose map implementations in the JDK comply. The \"destructive\" methods contained in this interface, that is, the\n methods that modify the map on which they operate, are specified to throw UnsupportedOperationException if this map does not support the\n operation.  If this is the case, these methods may, but are not required\n to, throw an UnsupportedOperationException if the invocation would\n have no effect on the map.  For example, invoking the putAll(Map) method on an unmodifiable map may, but is not required to, throw the\n exception if the map whose mappings are to be \"superimposed\" is empty. Some map implementations have restrictions on the keys and values they\n may contain.  For example, some implementations prohibit null keys and\n values, and some have restrictions on the types of their keys.  Attempting\n to insert an ineligible key or value throws an unchecked exception,\n typically NullPointerException or ClassCastException .\n Attempting to query the presence of an ineligible key or value may throw an\n exception, or it may simply return false; some implementations will exhibit\n the former behavior and some will exhibit the latter.  More generally,\n attempting an operation on an ineligible key or value whose completion\n would not result in the insertion of an ineligible element into the map may\n throw an exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface. Many methods in Collections Framework interfaces are defined\n in terms of the equals method.  For\n example, the specification for the containsKey(Object key) method says: \"returns true if and\n only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k)) .\" This specification should not be construed to imply that invoking Map.containsKey with a non-null argument key will cause key.equals(k) to\n be invoked for any key k .  Implementations are free to\n implement optimizations whereby the equals invocation is avoided,\n for example, by first comparing the hash codes of the two keys.  (The Object.hashCode() specification guarantees that two objects with\n unequal hash codes cannot be equal.)  More generally, implementations of\n the various Collections Framework interfaces are free to take advantage of\n the specified behavior of underlying Object methods wherever the\n implementor deems it appropriate. Some map operations which perform recursive traversal of the map may fail\n with an exception for self-referential instances where the map directly or\n indirectly contains itself. This includes the clone() , equals() , hashCode() and toString() methods.\n Implementations may optionally handle the self-referential scenario, however\n most current implementations do not do so. Unmodifiable Maps The Map.of , Map.ofEntries , and Map.copyOf static factory methods provide a convenient way to create unmodifiable maps.\n The Map instances created by these methods have the following characteristics: They are unmodifiable . Keys and values\n cannot be added, removed, or updated. Calling any mutator method on the Map\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained keys or values are themselves mutable, this may cause the\n Map to behave inconsistently or its contents to appear to change. They disallow null keys and values. Attempts to create them with null keys or values result in NullPointerException . They are serializable if all keys and values are serializable. They reject duplicate keys at creation time. Duplicate keys\n passed to a static factory method result in IllegalArgumentException . The iteration order of mappings is unspecified and is subject to change. They are value-based .\n Programmers should treat instances that are equal as interchangeable and should not use them for synchronization, or\n unpredictable behavior may occur. For example, in a future release,\n synchronization may fail. Callers should make no assumptions\n about the identity of the returned instances. Factories are free to\n create new instances or reuse existing ones. They are serialized as specified on the Serialized Form page. This interface is a member of the Java Collections Framework . Since:",
            "java.util.function.Consumer": "Consumer (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util.function Interface Consumer<T> Type Parameters: T - the type of the input to the operation All Known Subinterfaces: Stream.Builder <T> Functional Interface: This is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference. @FunctionalInterface public interface Consumer<T> Represents an operation that accepts a single input argument and returns no\n result. Unlike most other functional interfaces, Consumer is expected\n to operate via side-effects. This is a functional interface whose functional method is accept(Object) . Since:",
            "java.util.function.Function": "Function (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util.function Interface Function<T, R> Type Parameters: T - the type of the input to the function R - the type of the result of the function All Known Subinterfaces: UnaryOperator <T> Functional Interface: This is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference. @FunctionalInterface public interface Function<T, R> Represents a function that accepts one argument and produces a result. This is a functional interface whose functional method is apply(Object) . Since:"
        },
        "classes_labeled": {
            "util": "Utility",
            "EasyBind": "Utility",
            "PreboundBinding": "Parser",
            "Subscription": "Utility",
            "BooleanBinding": "User Interface",
            "ObjectBinding": "User Interface",
            "StringBinding": "User Interface",
            "ListProperty": "User Interface",
            "Property": "User Interface",
            "ChangeListener": "User Interface",
            "ObservableValue": "User Interface",
            "*": "Utility",
            "PseudoClass": "Computer Graphics",
            "Node": "Computer Graphics",
            "List": "Data Structure",
            "Map": "Data Structure",
            "Consumer": "Data Structure",
            "Function": "Parser"
        },
        "function_summaries": {
            "List": "Mapping",
            "Map": "Mapping",
            "function": "Mapping",
            "pseudoClassStateChanged": "Mapping",
            "subscribe": "Callback",
            "accept": "Callback",
            "getValue": "Operation",
            "setValue": "Modification",
            "addListener": "Callback",
            "setAll": "Mapping",
            "map": "Mapping",
            "removeListener": "Modification",
            "HashSet": "Mapping",
            "Set": "Mapping",
            "concurrent": "Mapping",
            "CoarseChangeFilter": "Mapping",
            "filter": "Filter",
            "findAny": "Mapping",
            "ifPresent": "Operation",
            "io": "Mapping",
            "Optional": "Mapping",
            "resolve": "Mapping",
            "orElse": "Mapping"
        },
        "functions_labeled": {
            "List": "Mapping",
            "Map": "Mapping",
            "function": "Mapping",
            "pseudoClassStateChanged": "Mapping",
            "subscribe": "Callback",
            "accept": "Callback",
            "getValue": "Operation",
            "setValue": "Modification",
            "addListener": "Callback",
            "setAll": "Mapping",
            "map": "Mapping",
            "removeListener": "Modification",
            "HashSet": "Mapping",
            "Set": "Mapping",
            "concurrent": "Mapping",
            "CoarseChangeFilter": "Mapping",
            "filter": "Filter",
            "findAny": "Mapping",
            "ifPresent": "Operation",
            "io": "Mapping",
            "Optional": "Mapping",
            "resolve": "Mapping",
            "orElse": "Mapping"
        }
    }
}